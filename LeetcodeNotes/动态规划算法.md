# 																																													动态规划算法

## 动态规划问题的性质

1. 重叠子问题 => 备忘录

2. 最优子结构

   > **要符合「最优子结构」，子问题间必须互相独立**

## 基本概念

- 带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。

- 啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 $f(20)$，向下逐渐分解规模，直到 $f(1)$ 和 $f(2)$ 这两个 base case，然后逐层返回答案，这就叫「自顶向下」。

- 啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 $f(1)$ 和$f(2)$开始往上推，直到推到我们想要的答案 $f(20)$​，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。

  > **动态规划的基础是递归**

## 术语

`状态转移方程` 你把 $f(n)$​ 想做一个状态 $n$​ ，这个状态 $n$​ 是由状态 $n - 1$​ 和状态 $n - 2$​​ 相加转移而来，这就叫状态转移，例如

<img src="动态规划算法.assets/image-20210802115033994.png" alt="image-20210802115033994" style="zoom: 80%;" />

> **状态转移方程直接代表着暴力解法**：**动态规划问题最困难的就是写出这个暴力解，即状态转移方程**。只要写出暴力解，优化方法无非是用备忘录或者 DP table，再无奥妙可言。

`状态压缩` 如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，只记录必要的数据

`子序列` 子序列不一定是连续的

`字串` 子串一定是连续的

`最长递增子序列(LIS)` Longest Increasing Subsequence

`最长连续序列(LCS)` Longest Consecutive Sequence

`最长连续递增序列(LCIS)` Longest Continuous Increasing Subsequence

`最长公共子序列(LCS)` Longest Common Subsequence

## 涉及题目的类型

- 子序列问题

  > **可以说只要涉及子序列问题，十有八九都需要动态规划来解决**

- 字串问题

- 背包问题

- 股票买卖问题

- 打家劫舍问题

- 博弈问题

## 相关题目

### 一维dp

#### [剑指 Offer 46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/) ★

题目描述：给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。

```C++
class Solution {
public:
    int translateNum(int num) {
        string s = to_string(num);
        int n = s.size();
        if(n == 1) return 1;
        // 定义dp[i] 为翻译 num[0..i] 的方法数
        vector<int> dp(n, 0);
        dp[0] = 1;
        dp[1] = (s.substr(0, 2) > "25") ? 1 : 2;

        for(int i = 2; i < n; i++){
            if(s[i - 1] == '0' || s.substr(i - 1, 2) > "25")
                dp[i] = dp[i - 1];
            else
                dp[i] = dp[i - 1] + dp[i - 2];
        }

        return dp[n - 1];
    }
};
```

`注`

1. 这道题其实是跳台阶问题的变形，即当当前考虑的数字和它的的前一位可以翻译成一个字母时  $dp[i] = dp[i - 1] + dp[i - 2]$

   否则，$dp[i] = dp[i - 1]$

#### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

一句话题目描述：返回可以凑成总金额所需的 **最少的硬币个数**

![image-20210802163705579](动态规划算法.assets/image-20210802163705579.png)

`注` 

1. 要注意第11行的判断，若减去当前硬币后值<0，则说明不可以减去

2. 本题的`状态转移方程`为

   <img src="https://labuladong.gitee.io/algo/images/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e8%af%a6%e8%a7%a3%e8%bf%9b%e9%98%b6/coin.png" alt="img" style="zoom:80%;" />

#### [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

见[二维dp（完全背包问题）](#二维dp（完全背包问题）)

#### [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/) ★

题目描述：给你一个整数数组 nums ，找到其中最长`严格递增` `子序列`的长度。

```C++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> dp(nums.size(), 1); //将dp[i]都初始化为1，因为子序列的长度至少为1，包含其自身

        for(int i = 0; i < nums.size(); i++){
            for(int j = 0; j < i; j++){
                if(nums[i] > nums[j]){
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
        }

        int maxL = dp[0];
        for(int i = 0; i < nums.size(); i++){
            maxL = max(maxL, dp[i]);
        }

        return maxL;
    }
};
```

`注`

1. 十分重要的是，本题中 $dp[i]$ 的定义为以 <u>数组中索引为 $i$ 的元素为结尾的最大子序列的长度</u>，所以要计算 $dp[i]$ 时，只需要在 $dp[j], j < i$ 的基础上 +1即可，当然需要满足，$nums[i] > nums[j]$​​，才能串起来成严格递增，所以本题的`状态转移方程`为

![image-20210802173230349](动态规划算法.assets/image-20210802173230349.png)

2. 本题的拓展请看下一标题，[354. 俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes/)

#### [354. 俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes/)

一句话题目描述：给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。

​	当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

​	请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面），例如：

![image-20210803111920185](动态规划算法.assets/image-20210803111920185.png)

```C++
class Solution {
public:
    int maxEnvelopes(vector<vector<int>>& envelopes) {
        /* 1. 最重要的一步：按照宽度升序排列，宽度相等的时候按照高度降序排列 */
        struct cmp{
            bool operator()(vector<int> envelope1, vector<int> envelope2){
                if(envelope1[0] == envelope2[0]) return envelope1[1] > envelope2[1];
                return envelope1[0] < envelope2[0];
            }
        };
        sort(envelopes.begin(), envelopes.end(), cmp());

        /* 2. 然后就只需要对高度序列做“最大递增子序列”算法即可 */
        vector<int> dp(envelopes.size(), 1); // 将dp[i]都初始化为1，因为子序列的长度至少为1，包含其自身

        for(int i = 0; i < envelopes.size(); i++){
            for(int j = 0; j < i; j++){
                if(envelopes[j][1] < envelopes[i][1]) dp[i] = max(dp[i], dp[j] + 1);
            }
        }

        int maxL = dp[0];
        for(int i = 0; i < envelopes.size(); i++){
            maxL = max(maxL, dp[i]);
        }

        return maxL;
    }
};
```

`注`

1. 本题中最关键的一条思路是要对二维数组进行排序，先对宽度进行升序排列（`为了确保之后的高度递增情况下，宽度一定满足`），宽度相同的情况下，对高度进行降序排列，如下图所示：

   <img src="https://labuladong.gitee.io/algo/images/%E4%BF%A1%E5%B0%81%E5%B5%8C%E5%A5%97/1.jpg" alt="img" style="zoom:33%;" />

   其中，之所以要对高度降序排列，是因为：

   > 假如我们仍像方法一一样，仅针对宽度排序。那么对于形如 [4, 4] 和 [4, 5]的两项，由于 [4, 4] 排序在 [4, 5]之前，这就导致仅考虑h时，我们认为 [4, 4]和 [4, 5]可以构成一组“套娃”。但是按照“二维严格升序”的定义，两个矩形的宽相等，不属于严格升序。
   >
   > 为了规避上述的问题，我们对宽度相等的两个矩形，使用高度降序排序，这样一来，上述问题的排列将变成： [4, 5], [4, 4]。在我们计算最长上升子序列时，由于 5>4，也就不会出现“错误套娃”。
   >
   
   然后就需要对高度进行最大递增子序列算法即可。

#### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

题目描述：给定一个整数数组 $nums$ ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和

```C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> dp(nums);

        for(int i = 1; i < nums.size(); i++){
            dp[i] = max(dp[i], dp[i - 1] + nums[i]);
        }

        int maxS = INT_MIN;
        for(int i = 0; i < nums.size(); i++){
            maxS = max(maxS, dp[i]);
        }

        return maxS;
    }
};
```

或者写成：

```C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        // 定义 dp[i] 为以下标为 i 的元素为结尾的最大子序和
        // 因此，dp[i] 最小也应该为包含自己本身，所以dp 用 nums 数组来初始化
        vector<int> dp(nums);
        int max_S = nums[0];

        for(int i = 1; i < nums.size(); i++){
            dp[i] = max(dp[i], dp[i - 1] + nums[i]);
            max_S = max(max_S, dp[i]);
        }
        
        return max_S;
    }
};
```

`注` ★

1. $dp$用$nums$数组来初始化，因为这里$dp[i]$ <u>数组中索引为 $i$​​ 的元素为结尾的最大连续子数组和</u>，所以$dp[i]$​​最小也应该为包含自己本身

#### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)★

题目描述：**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**，求盗窃的最高金额

```C++
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if(n == 1) return nums[0];

        // dp[i][j] 表示在盗窃前n间房的情况下，能抢到的最高金额
        vector<int> dp(n, 0);
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);

        for(int i = 2; i < n; i++){
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
        }

        return dp[n - 1];
    }
};
```

`注`

1. 本题较简单，自己写出来的，关键是定义一维dp
2. 本题的拓展是由于当前状态值和前两个状态有关，因此可以优化空间为O(1)，代码如下

```C++
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if(n == 1) return nums[0];

        // dp[i][j] 表示在盗窃前n间房的情况下，能抢到的最高金额
        // 空间优化，以prev代替dp[i - 2], curr = dp[i - 1]
        //vector<int> dp(n, 0);
        int prev = 0, curr = 0;

        for(int num : nums){
            //dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
            int temp = max(curr, prev + num);
            prev = curr;
            curr = temp;
        }

        return curr;
    }
};
```

#### [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

题目描述：相比于上一题，现在房屋围成一个圈，即是一个**环形数组**，因此首尾的房屋相连不能同时抢，求可以抢到的最大金额

```C++
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if(n == 1) return nums[0];

        // dp[i] 表示在盗窃前n间房的情况下，能抢到的最高金额
        vector<int> dp(n, 0);

        // 1. 抢第一间房，不抢最后一间房
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);

        for(int i = 2; i < n - 1; i++){
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
        }

        int res1 =  dp[n - 2];
        
        // 2. 抢最后一间房，不抢第一间房
        dp[0] = 0;
        dp[1] = nums[1];

        for(int i = 2; i < n; i++){
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
        }

        int res2 =  dp[n - 1];

        // 3. 不抢最后一间房，不抢第一间房，肯定不如case1和2来的大

        return max(res1, res2);
    }
};
```

`注`

1. 关键思路：将环形数组问题切开成两个子问题，也就是 1. 抢第一间房，不抢最后一间房；2. 抢最后一间房，不抢第一间房，分别处理；然后比较这两者之间的最大值

#### [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

`本题涉及树形DP` [见本小节](# 树形DP)

#### [剑指 Offer 14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)

题目描述：给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 $k[0],k[1]...k[m-1]$ 。请问 $k[0]*k[1]*...*k[m-1]$ 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

- `2 <= n <= 58`

```c++
class Solution {
public:
    int cuttingRope(int n) {
        // dp[i] 表示将长度为 i 的绳子切成若干段，能够得到的最大乘积
        if(n <= 1) return 0;
        vector<int> dp(n + 1, 0);
        dp[2] = 1;

        // 其中， j 表示长度为 i 的绳子第一次切的长度为 j
        for(int i = 3; i <= n; i++){
            for(int j = 2; j < i; j++){
                // 剪了第一刀长度为 j 后，可以不切了，则乘积为第一项；也可以在剩下的绳子再继续切，则乘积为第二项；取最大值
                dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));
            }
        }

        return dp[n];
    }
};
```

`注`

1. 这道题在做的过程中需要注意的是对$dp[i]$的定义，“注意不应该定义成   对长度为n的绳子，假设剪成$i$段，其最大乘积为$dp[i]$​”；因为我们并不关心到底是如何剪的，应该定义为：dp[i] 表示将长度为 $i$​ 的绳子切成若干段，能够得到的最大乘积，这样才能写出递推式

### 二维dp（三个for循环）

#### [剑指 Offer 60. n个骰子的点数](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/)

题目描述：把$n$个骰子扔在地上，所有骰子朝上一面的点数之和为$s$。输入$n$，打印出s的所有可能的值出现的概率。你需要用一个浮点数数组返回答案，其中第 $i$ 个元素代表这 $n$ 个骰子所能掷出的点数集合中第 $i$​​ 小的那个的概率

```C++
class Solution {
public:
    vector<double> dicesProbability(int n) {
        // dp[i][j] 定义为：表示投掷完 i 枚骰子后，点数 j 的出现次数
        // 包含 0 个骰子 ，点数为 0 ，所以分别多开一维
        vector<vector<int>> dp(n + 1, vector<int>(6 * n + 1, 0));

        // 初始化
        for(int j = 1; j <= 6; j++){
            // 只有 1 个骰子的时候，各个点数出现的次数均为 1
            dp[1][j] = 1;
        }

        // 已经丢下了 i 个骰子
        for(int i = 2; i <= n; i++){
            // 总的点数为 j
            for(int j = i; j <= 6 * i; j++){
                // 当前第 n 枚骰子的点数可能为 1, 2, ..., 6
                for(int cur = 1; cur <= 6; cur++){
                    if(j <= cur) break;
                    dp[i][j] += dp[i - 1][j - cur];
                }
            }
        }

        const int ALL = pow(6, n);
        vector<double> res;
        for(int i = n; i <= 6 * n; i++){
            res.push_back(dp[n][i] * 1.0 / ALL);
        }

        return res;
    }
};
```

`注`

1. 这里特别需要注意的是其状态转移方程为：

   单单看第 $n$ 枚骰子，它的点数可能为 $1 , 2, 3, ... , 6$​ ，因此投掷完 $n$ 枚骰子后点数 $j$ 出现的次数，可以由投掷完 $n-1$ 枚骰子后，对应点数 $j-1, j-2, j-3, ... , j-6$ 出现的次数之和转化过来。

    ```C++
    for (第n枚骰子的点数 cur = 1; cur <= 6; cur++) {
        dp[n][j] += dp[n - 1][j - cur];
    }
    ```
   
   
   ​	写成数学公式是这样的：$dp[n][j] = \sum_{i=1}^6 dp[n-1][j-i]$
   
   ​	其中，$n$ 表示阶段，$j$ 表示投掷完 $n$ 枚骰子后的点数和，$i$ 表示第 $n$​ 枚骰子会出现的六个点数
   
   **所以需要最内层的第三个for循环。**



### 二维dp（涉及两个字符串）

#### [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/) ★

题目描述：给定两个字符串 $text1$​ 和 $text2$​，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 0

```C++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));

        for(int i = 1; i <= text1.size(); i++){
            for(int j = 1; j <= text2.size(); j++){
                if(text1[i - 1] == text2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; // dp[i][j]的含义是text1[0..i-1], text2[0..j-1]的最大公共子序列，对应好的
                else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }

        return dp.back().back();
    }
};
```

`注`

1. 本题是字符串动态规划的经典题目，也是使用二维dp的经典题目

2. 同理为了匹配空字符串，同样dp数组有偏移，即$dp[i][j]$​​​的含义是text1[0..i-1], text2[0..j-1]的最大公共子序列，要注意，这个偏移影响的地方有`2`：

   - 比较明显的地方是：dp数组需要扩大+1

   - 需要特别注意的是：

     ```C++
     if(text1[i - 1] == text2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
     ```

     不能写成：

     ```C++
     if(text1[i] == text2[j]) dp[i][j] = dp[i - 1][j - 1] + 1;
     ```

     因为在$text1[i - 1] == text2[j - 1]$​ 条件下研究的是$dp[i][j]$​ ​

3. 最后，本题的状态转移方程为

   ![image-20210804105156626](动态规划算法.assets/image-20210804105156626.png)

   > 知道状态定义之后，我们开始写状态转移方程

   > 当 $text1[i - 1] == text2[j - 1]$ 时，说明两个子字符串的最后一位相等，所以最长公共子序列又增加了 1，所以 $dp[i][j] = dp[i - 1][j - 1] + 1$；举个例子，比如对于 ac 和 bc 而言，他们的最长公共子序列的长度等于 a 和 b 的最长公共子序列长度 0 + 1 = 1。
   > 当 $text1[i - 1] != text2[j - 1]$ 时，说明两个子字符串的最后一位不相等，那么此时的状态 $dp[i][j]$ 应该是 $dp[i - 1][j] 和 dp[i][j - 1]$ 的最大值。举个例子，比如对于 ace 和 bc 而言，他们的最长公共子序列的长度等于 ① ace 和 b 的最长公共子序列长度0 与 ② ac 和 bc 的最长公共子序列长度1 的最大值，即 1。
   > 综上状态转移方程为：

   > $dp[i][j] = dp[i - 1][j - 1] + 1   			text1[i−1]==text2[j−1]$​;
   > $dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) 	text1[i−1]!=text2[j−1]$​
   
4. 本题的拓展为[72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/) 


#### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/) ★

题目描述：给你两个单词 $word1$​ 和 $word2$​，请你计算出将 $word1$​ 转换成 $word2$​ 所使用的最少操作数 。

```C++
class Solution {
public:
    int minDistance(string word1, string word2) {
        // 由于要考虑空的字符串，所以dp初始化为字符串的长度+1，通常字符串的动态规划都这样初始化
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));
        // 第0列初始化，由s1转化成s2，随着s1的字符串长度每+1，删除操作+1
        for(int i = 0; i <= word1.size(); i++){
            dp[i][0] = i;
        }
        // 第0行初始化，由s1转化成s2，随着s2的字符串长度每+1，插入操作+1
        for(int j = 0; j <= word2.size(); j++){
            dp[0][j] = j;
        }

        for(int i = 1; i <= word1.size(); i++){
            for(int j = 1; j <= word2.size(); j++){
                if(word1[i -1] == word2[j - 1]) dp[i][j] = dp[i - 1][j -1];
                else{
                    dp[i][j] = min(min(dp[i - 1][j -1] + 1, dp[i][j -1] + 1), dp[i - 1][j] + 1); //min函数只能比较两者大小
                }
            }
        }

        return dp.back().back();
    }
};
```

`注`

1. 本题是字符串动态规划的经典题目，也是使用二维dp的经典题目

2. 第一个要思考清楚的问题是，dp数组的含义和大小，以及下标的对应关系

   - 首先，对于dp数组的大小，需要在 $s1.size()$ 和 $s2.size()$ 的基础上均+1，这是为了存储`空字符串`，如下图<u>粉红色的行和列</u>所示：

     <img src="动态规划算法.assets/image-20210803175242476.png" alt="image-20210803175242476" style="zoom: 67%;" />

   - 其次，对于$dp[i][j]$​​​​​​​而言,表示存储 $s1[0..i - 1]$​ 和 $s2[0..j - 1] $​($i>0, j>0$​) 的最小编辑距离

     所以，两重for循环都要$<=$

     ```C++
         for(int i = 1; i <= word1.size(); i++){
             for(int j = 1; j <= word2.size(); j++){
     ```

   > 比如对于本题而言，可以定义 $dp[i][j]$​​ 表示 $text1[0:i-1]$ 和$ text2[0:j-1]$ 的最长公共子序列。 （注：$text1[0:i-1]$ 表示的是 $text1$ 的 第 0 个元素到第 $i - 1$ 个元素，两端都包含）
   > 之所以 $dp[i][j]$ 的定义不是 $text1[0:i]$ 和 $text2[0:j]$ ，是为了方便当 $i = 0$ 或者 $j = 0$ 的时候，$dp[i][j]$ 表示的为空字符串和另外一个字符串的匹配，这样 $dp[i][j]$​ 可以初始化为 0.
   
3. 本题的核心思路是，

   - if ($word1[i - 1] == word2[j - 1]$)

     不操作

   - if ($word1[i - 1] != word2[j - 1]$)

     增 $dp(i, j - 1) + 1$,    **# 插入** **# 解释：** **# 我直接在 s1[i] 插入一个和 s2[j] 一样的字符** **# 那么 s2[j] 就被匹配了，前移 j，继续跟 i 对比** **# 别忘了操作数加一**

     删 $dp(i - 1, j) + 1$,    **# 删除** **# 解释：** **# 我直接把 s[i] 这个字符删掉** **# 前移 i，继续跟 j 对比** **# 操作数加一**

     换 $dp(i - 1, j - 1) + 1$ **# 替换** **# 解释：** **# 我直接把 s1[i] 替换成 s2[j]，这样它俩就匹配了** **# 同时前移 i，j 继续对比** **# 操作数加一**

   取步数最少的那一种+1步，即得$dp[i][j]$​

#### [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/) ★

题目描述：给你一个字符串 $s$​ 和一个字符规律 $p$​，请你来实现一个支持 $'.'$​ 和 $'*'$​ 的正则表达式匹配。

```C++
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size();
        int n = p.size();
        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));
        dp[0][0] = true;
        for(int j = 1; j <= n; j++){
            if(p[j - 1] == '*' && dp[0][j - 2] == true){
                dp[0][j] = true;
            }
        }

        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(s[i - 1] == p[j - 1] || p[j - 1] == '.') dp[i][j] = dp[i - 1][j - 1];
                else if (p[j - 1] == '*'){
                    // 碰到*，模式串应该往前找一位，然后和字符串的当前位对比
                    if(p[j - 2] != s[i - 1] && p[j - 2] != '.'){
                        dp[i][j] = dp[i][j - 2];
                    }
                    else{
                        // 真的去动手填表，就会立马理解
                        // 建议采用的例子 s = "aab"; p = "c*a*b"
                        // 匹配 0个 / 1位 / 多个
                        dp[i][j] = dp[i][j - 2] || dp[i][j - 1] || dp[i - 1][j];
                    }
                }
                // 都是正常字符且不匹配
                else{
                    dp[i][j] = false;
                }
            }
        }
		// dp表输出对比
        // for(int i = 0; i <= m; i++){
        //     for(int j = 0; j <= n; j++){
        //         cout << dp[i][j] << ", ";
        //     }
        //     cout << endl;
        // }

        return dp[m][n];
    }
};
```

`注`

1. 初始化

   ```C++
       dp[0][0] = true;
       for(int j = 1; j <= n; j++){
           if(p[j - 1] == '*' && dp[0][j - 2] == true){
               dp[0][j] = true;
           }
       }
   ```

   需要特别注意这里的初始化，从下面的dp表中也可以看出，类似于$c*a*$的模式串是可以成功匹配空字符串的

2. 状态转移方程

   这道题最麻烦的就是状态转移，首先确定dp数组的含义：$dp[i][j]$表示字符串的前$i - 1$位与模式串的前$j - 1$位能否成功匹配

   然后状态转移分为一下几种情况：

   - $p[j -1] == s[i - 1]$ 或者 $p[j - 1] == '.'$    说明当前考虑位可以匹配，则，$dp[i][j]$由前面的子问题$dp[i - 1][j - 1]$​决定 
   - $p[j -1] != s[i - 1]$​​​ 
     - 如果$p[j -1] == '*' $ ，则需要考虑模式串的前一位是否与字符串匹配（这是因为*是对前一位的拷贝）
       - 如果前一位不匹配，则拷贝0次，$dp[i][j] = dp[i][j - 2]$​
       
       - 如果是匹配的，则尝试拷贝0次/1次/2次
       
        > 这里拷贝0次和和上一条的区别在于：
         > 例子：$s:aab$，$p:aabb*$,虽然$j-2$和$i-1$相等，但是$dp[i][j-2]$已经匹配了，直接删去$j-1$和$j-2$​​即可（你来之前我们就已经是总冠军了）
         >
         > $dp[i][j] = dp[i][j-2] $(取0个字符)
         >

3. dp表

4. 真的去动手填表，就会立马理解，例如下表和状态转移之间的对应关系，特别关注蓝色圈的那个点







### 二维dp（涉及一个字符串）

#### [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

题目描述：给你一个字符串 $s$​ ，找出其中最长的回文子序列，并返回该序列的长度。

```C++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int sz = s.size();
        vector<vector<int>> dp(sz, vector<int>(sz, 0));

        // base case 
        for(int i = 0; i < sz; i++){
            dp[i][i] = 1; // 重要，将对角线元素初始化为1
        }

        /* 为了确保计算当前dp[i][j]时，其左边，做下，下边的单元都已经先计算完毕，因此采用倒序遍历的方式 */
        for(int i = sz - 1; i >= 0; i--){
            for(int j = i + 1; j < sz; j++){
                if(s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1] + 2;
                else{
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[0][sz - 1];
    }
};
```

`注`

1. 此处dp数组的定义就很直接，没有偏移，因为不涉及两个字符串，直接定义为：**在子串`s[i..j]`中，最长回文子序列的长度为`dp[i][j]`**

2. 本题的状态转移方程为

   ```C++
   if (s[i] == s[j])
       // 它俩一定在最长回文子序列中
       dp[i][j] = dp[i + 1][j - 1] + 2;
   else
       // s[i+1..j] 和 s[i..j-1] 谁的回文子序列更长？
       dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
   ```

3. 本题中最关键的是遍历的顺序，如下图dp数组的图所示

   ![image-20210804230554609](动态规划算法.assets/image-20210804230554609.png)

   **为了保证每次计算`dp[i][j]`，左、下、左下三个方向的位置已经被计算出来，只能`斜着遍历`或者`反着遍历`**

4. #### [1312. 让字符串成为回文串的最少插入次数](https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/)  

   >  ​	属于 #516 最长回文子序列的子题，所以可以先寻找 s 的最长回文串，然后再把 s 的长度减去其就是最少的插入次数

#### [887. 鸡蛋掉落](https://leetcode-cn.com/problems/super-egg-drop/)「困难」

题目描述：k个鸡蛋，n层楼，计算最少需要多少次可以确定鸡蛋从哪一楼掉下会破碎的最小值。

> 参考1：[liweiwei的题解](https://leetcode-cn.com/problems/super-egg-drop/solution/dong-tai-gui-hua-zhi-jie-shi-guan-fang-ti-jie-fang/)

##### 解法1「部分case超时」

```C++
class Solution {
public:
    int superEggDrop(int k, int n) {
        vector<vector<int>> dp(n + 1, vector<int>(k + 1, 1001));

        // 楼层为0，无法测量
        for(int j = 0; j <= k; j++){
            dp[0][j] = 0;
        }
        // 楼层为1，只要1个鸡蛋
        dp[1][0] = 0;
        for(int j = 0; j <= k; j++){
            dp[1][j] = 1;
        }
        // 鸡蛋为0，无法测量; 鸡蛋为1，测量数=楼层数
        for(int i = 0; i <= n; i++){
            dp[i][0] = 0;
            dp[i][1] = i;
        }

        for(int i = 2; i <= n; i++){
            for(int j = 2; j <= k; j++){
                for(int k = 1; k <= i; k++){
                    dp[i][j] = min(dp[i][j], max(dp[k - 1][j - 1], dp[i - k][j]) + 1);
                }
            }
        }

        return dp[n][k];
    }
};
```

`注`

1. 本题中dp数组的含义为：$dp[i][j]$​：一共有 i 层楼梯`（注意：这里 i 不表示高度）`的情况下，使用 j 个鸡蛋的最少实验的次数

   说明：

   - i 表示的是楼层的大小，不是高度（第几层）的意思，例如楼层区间 [8, 9, 10] 的大小为 33
   - j 表示可以使用的鸡蛋的个数，它是约束条件「习惯于将限制条件写在第二维的位置」

   依次可以画出dp数组的表格如下图所示：

   ![image-20210805175503539](动态规划算法.assets/image-20210805175503539.png)

2. 推导状态转移方程「可以参考https://www.bilibili.com/video/BV1KE41137PK?from=search&seid=17973611971894816621」李永乐老师的理论分析视频

   即对于$dp[i][j]$​而言，

   ![image-20210805175822882](动态规划算法.assets/image-20210805175822882.png)

   前一项表示任从第k层扔下，鸡蛋碎了，因此楼层选择从[1, k-1] 共k-1层，鸡蛋剩余j- 1个；后一项表示第k层扔下，鸡蛋没碎，因此楼层选择从[k+1， i] ,共i-k层，鸡蛋数量不变；由于考虑最坏情况，所以在这两者之中选最大值；最后由于k任取，所以遍历k，取得最优的方案需要的最多的次数。

3. 但是由于k的线性寻找，时间复杂度，$O(N^2K)$​​，会有部分case超时；因此将k的寻找用二分搜索代替

##### 解法2

```C++
class Solution {
public:
    int superEggDrop(int k, int n) {
        vector<vector<int>> dp(n + 1, vector<int>(k + 1, 10001));

        // 楼层为0，无法测量
        for(int j = 0; j <= k; j++){
            dp[0][j] = 0;
        }
        // 楼层为1，只要1个鸡蛋
        dp[1][0] = 0;
        for(int j = 0; j <= k; j++){
            dp[1][j] = 1;
        }
        // 鸡蛋为0，无法测量; 鸡蛋为1，测量数=楼层数
        for(int i = 0; i <= n; i++){
            dp[i][0] = 0;
            dp[i][1] = i;
        }

        for(int i = 2; i <= n; i++){
            for(int j = 2; j <= k; j++){

                /* 从1 枚举到 i 会超时，将这一段换成二分查找*/
                // for(int k = 1; k <= i; k++){
                //     dp[i][j] = min(dp[i][j], max(dp[k - 1][j - 1], dp[i - k][j]) + 1);
                // }

                int left = 1;
                int right = i;
                int res = INT_MAX;

                while(left <= right){
                    int mid = left + (right - left) / 2;
                    if(dp[mid - 1][j - 1] == dp[i - mid][j]){
                        res = min(res, dp[mid - 1][j - 1] + 1);
                        break;
                    } 
                    else if(dp[mid - 1][j - 1] < dp[i - mid][j]){
                        left = mid + 1;
                        res = min(res, dp[i - mid][j - 1] + 1);
                    }
                    else if(dp[mid - 1][j - 1] > dp[i - mid][j]){
                        right = mid - 1;
                        res = min(res, dp[mid - 1][j - 1] + 1);
                    } 
                }

                dp[i][j] = res;
            }
        }

        return dp[n][k];

    }
};
```

`注`

1. 能够将k的寻找写成二分搜索的形式是因为，$dp[k - 1][j - 1]$是一个随着k的增加而单调递增的函数（不严格单调），而$dp[i - k][j]$​​​是一个随着k的增加而单调递减的函数（不严格单调），所以这两者`较大值的最小值`必在其`交点处`取得，如下图所示：

   ![image-20210805180816469](动态规划算法.assets/image-20210805180816469.png)

   这里唯一需要注意的是：这个交点的横坐标不一定是整数，而楼层k必须是整数，所以在不是整数的情况下，还需呀对比交点左右两侧的k的整数点取其最小值，所以代码中需要引入res时刻记录。

#### [312. 戳气球](https://leetcode-cn.com/problems/burst-balloons/) 【和鸡蛋掉落相似】

`注` **这个题和鸡蛋掉落的题目比较相似，都涉及到3个for循环，最内层的k用来做选择，外层的两个用来状态的更迭**

题目描述：有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。

现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。

求所能获得硬币的最大数量。

```C++
class Solution {
public:
    int maxCoins(vector<int>& nums) {
        int n = nums.size();
        // 为了实现两侧气球的硬币数为1 添加两侧的虚拟气球 方便处理边界情况
        vector<int> temp(n + 2);
        temp[0] = temp[n + 1] = 1;
        for(int i = 1; i <= n; i++){
            temp[i] = nums[i - 1];
        }

        // dp[i][j] = x 表示的是 戳破气球 (i, j)开区间 之间所有的气球，可以获得最高分数为 x
        vector<vector<int>> dp(n + 2, vector<int>(n + 2, 0));

        // 由于需要左下方的信息，所以选择从下到上，从左到右的遍历方式（斜着遍历也可以，但比较麻烦）
        for(int i = n; i >= 0; i--){
            for(int j = i + 1; j < n + 2; j++){
                for(int k = i + 1; k < j; k++){
                    // 状态转移方程，假设最后一个被戳破的气球为 k
                    // 为了最后戳破气球 k， 首先要戳破 (i, k)内的所有气球，再戳破 (k, j)的所有气球
                    // 最后剩下 k, 相邻的气球就是 i 和 j
                    dp[i][j] = max(dp[i][j], dp[i][k] + temp[i] * temp[j] * temp[k] + dp[k][j]);
                }
            }
        }

        // 对应 dp[i][j] 的定义
        return dp[0][n + 1];
    }
};
```

`注`

1. 本题最为关键的是确定$dp[i][j]$​ 的含义，见代码内注释

### 二维dp（0-1背包问题）

#### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

题目描述：给你一个 **只包含正整数** 的 **非空** 数组 $nums$​ 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

`核心思想` 将这个问题理解成一个0-1背包问题，

> 背包问题原型：给你一个可装载重量为 $W$ 的背包和 $N$ 个物品，每个物品有重量和价值两个属性。其中第 $i$ 个物品的重量为 $wt[i]$，价值为 $val[i]$，现在让你用这个背包装物品，最多能装的价值是多少？

> 那么对于这个问题，我们可以先对集合求和，得出 $sum$​，把问题转化为背包问题：
> **给一个可装载重量为 $sum / 2$​ 的背包和 $N$​ 个物品，每个物品的重量为 $nums[i]$​。现在让你装物品，是否存在一种装法，能够恰好将背包装满**？

```C++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int n = nums.size();
        int sum = 0;
        for(int num : nums){
            sum += num;
        }
        if(sum % 2 != 0) return false;
        sum = sum / 2;

        vector<vector<bool>> dp(n + 1, vector<bool>(sum + 1, false));
        for(int i = 0; i <= n; i++){
            dp[i][0] = true;
        }

        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= sum; j++){
                // 1. 超过背包容量
                if(j - nums[i - 1] < 0) dp[i][j] = dp[i - 1][j];
                // 2. 选择是否装入
                else
                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];
            }
        }

        return dp[n][sum];
    }
};
```

`注`

1. 本题的dp数组如下图所示：

   <img src="动态规划算法.assets/image-20210805223324880.png" alt="image-20210805223324880" style="zoom: 50%;" />

   2. 重点关注：

      ```C++
      dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]]
      ```

### 二维dp（完全背包问题）

**「完全背包问题与0-1背包问题的区别在于其每件物品的数量是无限的」**

#### [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

题目描述：给你一个整数数组 $coins$ 表示不同面额的硬币（**假设每一种面额的硬币有无限个**），另给一个整数 $amount$ 表示总金额。请你计算并返回可以凑成总金额的硬币组合数

```C++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        int n = coins.size();

        vector<vector<int>> dp(n + 1, vector<int> (amount + 1, 0));
        for(int i = 0; i <= n; i++){
            dp[i][0] = 1;
        }

        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= amount; j++){
                if(j - coins[i - 1] < 0){
                    dp[i][j] = dp[i - 1][j];
                }
                else{
                    dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]];
                }
            }
        }

        return dp[n][amount];
    }
};
```

`注`

1. $dp[i][j]$表示：使用$coins$的前$i$​个硬币（`可以重复`）可以凑出多少种总和为sum的组合；因此其表格如下所示：

   <img src="动态规划算法.assets/image-20210805232634033.png" alt="image-20210805232634033" style="zoom:50%;" />

### 二维dp（最小路径问题）

#### [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

`本题自己写出一次过，不作解释，代码参考leetcode`

#### [120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/) ★★

题目描述：给定一个三角形 $triangle$​ ，找出自顶向下的最小路径和

```C++
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();

        vector<vector<int>> dp(n, vector<int>(n, 0));
        //初始化
        dp[0][0] = triangle[0][0];

        for(int i = 1; i < n; i++){
            for(int j = 0; j <=i; j++){
                if(j == 0) dp[i][j] = dp[i - 1][j] + triangle[i][j];
                else if(j == i) dp[i][j] = dp[i - 1][j - 1] + triangle[i][j];
                else dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + triangle[i][j];
            }
        }

        int res = INT_MAX;
        for(int j = 0; j < n; j++){
            if(dp[n - 1][j] < res) res = dp[n - 1][j];
        }

        return res;
    }
};
```

`注`

1. 特别小心的是，这类题目中，在考虑状态转移方程中，是要每一行根据上一行的结果来递推，而不要在同一行中递推（这是因为没法在同一行中移动）；例如本题的状态转移方程为：

   $dp[i][j] = min{dp[i][j], dp[i - 1][j - 1]} + triangle[i][j]$，然后根据边界情况删减（最左侧取不到$dp[i - 1][j - 1]$， 最右侧取不到 $dp[i - 1][j]$ ）
   
   dp表格如下所示：
   
   ![image-20210816114414462](动态规划算法.assets/image-20210816114414462.png)
   
2. 在上述代码中，我们定义了一个 $n$​ 行 $n$​ 列 的 dp 数组（ $n$​ 是三角形的行数）。
   但是在实际递推中我们发现，计算 $dp[i][j]$​ 时，只用到了上一行的 $dp[i - 1][j]$​ 和 $dp[i - 1][j - 1]$​
   因此 $dp$​ 数组不需要定义 $n$​ 行，只要定义 1 行就阔以啦
   所以我们稍微修改一下上述代码，将 $i$​ 所在的维度去掉（如下），就可以将 $O(N^2)$​ 的空间复杂度优化成 $O(N)$​ 啦～
   
   ```C++
   class Solution {
   public:
       int minimumTotal(vector<vector<int>>& triangle) {
           int n = triangle.size();
   
           //空间优化,将 i 所在的维度去掉
           //vector<vector<int>> dp(n, vector<int>(n, 0));
           vector<int> dp(n, 0);
   
           //初始化
           dp[0] = triangle[0][0];
   
           for(int i = 1; i < n; i++){
               for(int j = i; j >= 0; j--){ //防止dp[i - 1]被覆盖，采取从右到左填表
                   if(j == 0) dp[j] = dp[j] + triangle[i][j];
                   else if(j == i) dp[j] = dp[j - 1] + triangle[i][j];
                   else dp[j] = min(dp[j], dp[j - 1]) + triangle[i][j];
               }
           }
   
           int res = INT_MAX;
           for(int j = 0; j < n; j++){
               if(dp[j] < res) res = dp[j];
           }
   
           return res;
       }
   };
   ```
   
   - **但是此时特别需要注意，为了避免计算结果被覆盖，需要j从右到左填表，例如，如果还是按照以往的方式从左到右：**
     - **$i = 0, j = 0  ->   dp[0] = 2$​​**
     - **$i = 1, j = 0 ->dp[0] = 2 + 3 = 5, dp[1] = dp[0] + 4 = 9（错误，应该是2 + 4 = 6）$​​**
   
3. 本题的进阶题如下[931. 下降路径最小和](https://leetcode-cn.com/problems/minimum-falling-path-sum/)


#### [931. 下降路径最小和](https://leetcode-cn.com/problems/minimum-falling-path-sum/)

题目描述：一个 $n x n$ 的 方形 整数数组 matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。

`下降路径` 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）

```C++
class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));

        // 初始化：对于首行而言，每个位置的「最小成本」就是其矩阵值
        for(int j = 0; j < n; j++){
            dp[0][j] = matrix[0][j];
        }

        for(int i = 1; i < m; i++){
            for(int j = 0; j < n; j++){
                if(j == 0) dp[i][j] = min(dp[i - 1][j], dp[i - 1][j + 1]) + matrix[i][j];
                else if(j == n - 1) dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + matrix[i][j];
                else 
                    dp[i][j] = min(min(dp[i - 1][j - 1], dp[i - 1][j]), dp[i - 1][j + 1]) + matrix[i][j];
            }
        }

        int res = INT_MAX;
        for(int j = 0; j < n; j++){
            if(dp[m - 1][j] < res) res = dp[m - 1][j];
        }

        return res;
    }
};
```

`注`

1. 本题要注意第一行的初始化，和后续状态转移方程（$dp[i][j]=min(dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1])+matrix[i][j]$）要根据不同的位置进行删减

   ```C++
   if(j == 0) dp[i][j] = min(dp[i - 1][j], dp[i - 1][j + 1]) + matrix[i][j];
                   else if(j == n - 1) dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + matrix[i][j];
                   else 
                       dp[i][j] = min(min(dp[i - 1][j - 1], dp[i - 1][j]), dp[i - 1][j + 1]) + matrix[i][j];
   ```

   <img src="动态规划算法.assets/image-20210815233243515.png" alt="image-20210815233243515" style="zoom:67%;" />

### 二维dp（博弈问题）

#### [877. 石子游戏](https://leetcode-cn.com/problems/stone-game/)

题目描述：A和B轮流从piles[i]这堆石头中取一堆，A先开始。 每回合，玩家从行的开始或结束处取走整堆石头，手中石子最多的玩家获胜

`博弈问题的数学方法：先手必赢`

![image-20210810215950489](动态规划算法.assets/image-20210810215950489.png)

```C++
class Solution {
public:
    bool stoneGame(vector<int>& piles) {
        const int n = piles.size();

        // dp[i][j]表示，在区间piles[i..j]内，先手相较于后手在最优条件下可以获得的相对分数
        vector<vector<int>> dp(n, vector<int>(n, 0));
        for(int i = 0; i < n; i++){
            dp[i][i] = piles[i];
        }

        for(int step = 1; step < n; step++){
            for(int i = 0; i + step < n; i++){
                int j = i + step;
                dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1]);
            }
        }

        return dp[0][n - 1];
    }
};
```

`注`

1. 本题中的$dp[i][j]$​定义为：在区间$piles[i..j]$​​​​​内，先手相较于后手在最优条件下可以获得的**分数差**；因此状态转移方程可以理解为：

> 对于先手玩家，有两种拿法：
> 拿开头的 $piles[i]$​：先手玩家手里有了 $piles[i]$​，因为在区间 $[i + 1, j]$​ 中只能由后手玩家来选择，则 $dp[i + 1][j]$​ 表示的是后手玩家在这个区间内(此时，后手玩家变为先手)比先手玩家多的最大石子个数，反过来 $-dp[i + 1][j]$​ 表示在这个区间内，先手玩家比后手玩家多的最大石子个数；状态转移方程：$dp[i][j] = piles[i] + (-dp[i + 1][j])$​
> 拿结尾的 piles[j]：先手玩家手里有了 $piles[j]$​，因为在区间 $[i, j - 1]$​ 中只能由后手玩家来选择，则 $dp[i][j - 1]$​ 表示的是后手玩家在这个区间内(此时，后手玩家变为先手)比先手玩家多的最大石子个数，反过来 $-dp[i][j - 1]$​ 表示在这个区间内，先手玩家比后手玩家多的最大石子个数； 状态转移方程：$dp[i][j] = piles[j] + (-dp[i][j - 1])$​

2. 初始化的过程如下图所示：

   <img src="动态规划算法.assets/image-20210810222042157.png" alt="image-20210810222042157" style="zoom: 80%;" />

   3. ★ 本题中最为关键的是`填表顺序`，由于$dp[i][j]$​ 由其左边和下边的方格决定，因此填表的顺序应该为`斜向上`,如上图中随着值增大的方向；其中最为关键的是歇着填表的代码为：
   
      ```C++
        for(int step = 1; step < n; step++){
                  for(int i = 0; i + step < n; i++){
                      int j = i + step;
      ```
   
      需要自己一步步根据找规律来写出

### 二维dp（dp数组偏移问题典型）

#### [494. 目标和](https://leetcode-cn.com/problems/target-sum/) ★

题目描述：整数数组 nums 和一个整数 target ，向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。

```C++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sz = nums.size();
        int sum = 0;
        for(auto num : nums){
            sum += num;
        }

        // 预判断，必要
        if(abs(target) > abs(sum)) return 0;

        // 初始化
        vector<vector<int>> dp(sz, vector<int>(2 * sum + 1, 0));
        if(nums[0] == 0){
            dp[0][sum] = 2;
        }
        else{
            dp[0][sum - nums[0]] = 1;
            dp[0][sum + nums[0]] = 1;
        }

        for(int i = 1; i < sz; i++){
            for(int j = 0; j < 2 * sum + 1; j++){
                // 边界问题处理
                int l = (j - nums[i]) >= 0 ? j - nums[i] : 0;
                int r = (j + nums[i]) <= 2 * sum ? j + nums[i] : 0;
                dp[i][j] = dp[i - 1][l] + dp[i - 1][r];
            }
        }

        return dp[sz - 1][sum + target];
    }
};
```

`注`

1. 首先，像一般的动态规划的题目一样，确定 $dp[i][j]$ 的含义为，在 $nums[0..i]$ 中使得添加符号后的结果为 $j$ 的方法数量；其次确定状态转移方程为：$dp[ i ][ j ] = dp[ i - 1 ][ j - nums[ i ] ] + dp[ i - 1 ][ j + nums[ i ] ]$ ，可以理解为 $nums[i]$ 这个元素我可以执行加，还可以执行减，那么我$dp[i][j]$​ 的结果值就是加/减之后对应位置的和。

2. 这道题的关键之一是确定 打表格的大小问题，如果设计成如下的样子，负数（一直 ‘-’）就会没有填的地方

   <img src="动态规划算法.assets/image-20210815215733116.png" alt="image-20210815215733116" style="zoom:80%;" />

   因此正确的列数应该为 $2 * sum + 1$​ 列（-/0+），如下所示

   <img src="动态规划算法.assets/image-20210815215948473.png" alt="image-20210815215948473" style="zoom: 50%;" />

   3. 本题的第二个关键是初始化问题，要注意列有偏移，因此在设计数组前0个数字通过运算得到本身的初始化语句中，要注意加上偏移：

      > 一开始想了很久为什么 $nums[0] == 0$​ 的时候是 $dp[0][sum] = 2$​ 而不是$dp[0][0] = 2$​，后来才反应过来自己是被自己绕进去了。 这里的sum其实是$ [0, 2*sum+1] $​这个范围里的第$sum+1$​个元素，实际上就是答主第二个表格里的“0”，只不过由于数组下标不能为负，跟官方答案一样把负数和0右移了，因此这里才是$dp[0][sum] = 2$。如果根据答主画的第二个表格来说的话确实是$dp[0][0] = 2$​​ 
      
   4. 最后一个关键是：这道题有个坑的地方，就是$nums[0]$可能等于0，这样初始化dp数组第一行的时候很可能踩坑，因为如果$nums[0]==0$那么$dp[0][sum]$需要初始化为2，因为加减0都得0。
   
      

### 多维dp （股票买卖问题）

`注` leetcode上股票买卖问题的题目主线是：

#### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

题目描述：只能买卖**一次**股票，计算最大利润

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // 不管3721，使用动态规划
        // 定义 dp[i][j] 为 当在第 i 天结束时，手上的持股状态为 j 时 手上所持有的现金数
        // j = 0 未持股；j = 1 持股
        int n = prices.size();
        if(n == 0) return 0; // 注意输入为 “[]” 的情况，不加这个会越界
        vector<vector<int>> dp(n, vector<int>(2, 0));
        dp[0][0] = 0;
        dp[0][1] = -prices[0];

        for(int i = 1; i < n; i++){
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            //dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1]);
            dp[i][1] = max(-prices[i], dp[i - 1][1]);
        }

        return dp[n - 1][0];
    }
};
```

`注` 

1. 在这一系列的股票买卖类的题目中，特别需要注意第$0$天的现金数。

2. 本题中$dp[i][j]$​​的含义为：在第 $i$ 天结束的时候，手上持股状态为 $j$ 时，我们所持有的`现金数`

3. 确定了上述的定义后，在状态转移方程的确定过程中，非常容易出错的一点会出现，首先，根据下图

   ![image-20210808221259182](动态规划算法.assets/image-20210808221259182.png)

   确定状态的转移，其次写出方程

   ![image-20210808221346781](动态规划算法.assets/image-20210808221346781.png)

   特别注意，下面的这种写法是错误的，因为题目要求只能买卖一次，所以如果今天持股了的话，今天的现金数量一定是开始的第0天-今天的股价；而下面的这种写法是在可以卖卖多次的情况下，因为如果题目允许交易多次，就说明可以从直接从昨天的未持股状态变为今天的持股状态，因为昨天未持股状态可以代表之前买过又卖过后的状态，也就是之前交易过多次后的状态。也就是下面的代码：

   ```C++
   dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1]);
   ```

   正确的写法是：

   ```C++
   dp[i][1] = max( - prices[i], dp[i - 1][1]);
   //- prices[i]这里可以理解为dp[0][0] - prices[i]，这里为什么是dp[0][0] - prices[i]，因为只有这样才能保证只买一次，所以需要用一开始初始化的未持股的现金dp[0][0]减去当天的股价
   ```

#### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

题目描述：只能买卖**多次**股票，计算最大利润

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2, 0));
        dp[0][0] = 0;
        dp[0][1] = -prices[0];

        for(int i = 1; i < n; i++){
            dp[i][0] = max(dp[i - 1][1] + prices[i], dp[i - 1][0]);
            dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1]);
            //dp[i][1] = max( - prices[i], dp[i - 1][1]);
        }

        return dp[n - 1][0];
    }
};
```

`注` 

1. 和上一题的差别只在‘’//‘’的那一行

#### [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)★

题目描述：最多进行2笔买卖，计算获取的最大利润

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        // 三维dp[i][j][k] 表示，在第i天结束的时候，交易了j次，手上持股状态为k的时候现金数
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(3, vector<int>(2, 0)));

        dp[0][0][0] = 0;
        dp[0][0][1] = INT_MIN;
        dp[0][1][0] = 0;
        dp[0][1][1] = -prices[0];
        dp[0][2][0] = 0;
        dp[0][2][1] = -prices[0];

        for(int i = 1; i < n; i++){
            for(int j = 1; j <= 2; j++){
                dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);
                dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);
            }
        }

        return dp[n - 1][2][0];
    }
};
```

`注`

1. ★首先，从这道题开始应该注意到；`是否允许在同一天买卖股票`，我的统一操作是：**可以**。

2. 然后，就是正常的先规定$dp[i][j][k]$​​的定义为：在第i天结束的时候，交易了j次，手上持股状态为k的时候现金数

3. ★重要的是，这道题的初始化，对于$dp[0][0][1] = INT MIN$​​;不可能在交易0次的情况下，持有股票

   > 为什么需要负无穷？因为不可能发生的状态应该设置为一个不可能达到的最小值. 买入时某天的手中的现金可能是负数, 如果初始化为0就会出错. 所以应该初始化为一个不会对后续转移造成影响的值

   而对于$dp[0][2][1] = -prices[0]$，可以理解为在第0天买入->卖出->买入，所以此时的现金是当日股价的相反数

4. 最后本题的状态转移方程如下图所示：

   ![image-20210809162716862](动态规划算法.assets/image-20210809162716862.png)
   
   或者：
   
   ![image-20210809171315881](file://C:\Users\mWX1034919\Desktop\LeetcodeNotes-master\%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95.assets\image-20210809171315881.png?lastModify=1628500932)

#### [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

题目描述：最多交易k笔买卖，计算最大利润

```C++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        int n = prices.size();

        // 特殊判断
        if (k == 0 || n < 2) {
            return 0;
        }

        vector<vector<vector<int>>> dp(n, vector<vector<int>>(k + 1, vector<int>(2, 0)));
        // 初始化
        dp[0][0][0] = 0;
        dp[0][0][1] = INT_MIN;
        for(int j = 1; j <= k; j++){
            dp[0][j][0] = 0;
            dp[0][j][1] = -prices[0];
        }

        for(int i = 1; i < n; i++){
            for(int j = 1; j <= k; j++){
                dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);
                dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j -1][0] - prices[i]);
            }
        }

        return dp[n - 1][k][0];
    }
};
```

`注`

1. 这个代码参考上一题自己写的，增加了交易次数为k的限制条件，其中第二位开成$k+1$ ,是为了满足交易k次，$j = 0$ 不能算一次

2. 状态转移：

   ![image-20210809171315881](动态规划算法.assets/image-20210809171315881.png)

#### [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

题目描述：交易次数不限，但是卖出之后需要间隔一天才能继续买入

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if(n < 2) return 0; 
        vector<vector<int>> dp(n, vector<int>(2, 0));
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        dp[1][0] = max(dp[0][1] + prices[1], dp[0][0]);
        dp[1][1] = max(dp[0][1], -prices[1]);

        for(int i = 2; i < n; i++){
            dp[i][0] = max(dp[i - 1][1] + prices[i], dp[i - 1][0]);
            dp[i][1] = max(dp[i - 2][0] - prices[i], dp[i - 1][1]);
        }

        return dp[n - 1][0];
    }
};
```

`注`

1. 这题与122题，只相差下面这行的$i - 2$​ 处，然后为了避免越界，将i=1的情况放在初始化的过程中

#### [714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2, 0));
        dp[0][0] = 0;
        dp[0][1] = -prices[0];

        for(int i = 1; i < n; i++){
            dp[i][0] = max(dp[i - 1][1] + prices[i] - fee, dp[i - 1][0]);
            dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1]);
            //dp[i][1] = max( - prices[i], dp[i - 1][1]);
        }

        return dp[n - 1][0];
    }
};
```

`注`

1. 这题很简单，与122题只相差$dp[i][0] = max(dp[i - 1][1] + prices[i] - fee, dp[i - 1][0]);$​ ,每次卖出多减去一个fee即可，其他均无变化。

### 树形DP

#### [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/) ★

```C++
class Solution {
public:
    int rob(TreeNode* root) {
        vector<int> dp = robTree(root);
        return max(dp[0], dp[1]);
    }

    // 返回一个大小为2的一维dp数组，dp[0]表示不偷当前节点可获的最大金额，dp[1]表示偷当前节点可获的最大金额
    vector<int> robTree(TreeNode* curr){
        if(curr == NULL) return {0, 0};
        // 后序遍历
        vector<int> left = robTree(curr->left);
        vector<int> right = robTree(curr->right);
        // 不偷当前的节点
        int val1 = max(left[0], left[1]) + max(right[0], right[1]);
        // 偷当前的节点
        int val2 = curr->val + left[0] + right[0];

        return {val1, val2};
    }
};
```

`注` 

1. 这道题不同于之前在平时我们习惯了在一维数组或者二维数组上推导公式；这里换成了树形DP，本质上$robTree()$的返回值就是一个大小为2的一维$dp$数组，$dp[0]$表示不偷当前节点可获的最大金额，$dp[1]$表示偷当前节点可获的最大金额

2. 这个dp数组存在的疑问是：长度为2的数组怎么标记树中每个节点的状态呢；其实**在递归的过程中，系统栈会保存每一层递归的参数（<u>每个节点都保存了一个$dp[0][1]$数组）</u>**，所以对于我们最后要求的根节点$root$而言，是通过二叉树自下向上后序遍历一层层向上报告而来的；一个比较直观的图如下所示：

   <img src="动态规划算法.assets/image-20210810151849181.png" alt="image-20210810151849181" style="zoom:80%;" />

## 参考资料

<img src="动态规划算法.assets/image-20210806180356151.png" alt="image-20210806180356151" style="zoom:50%;" />
